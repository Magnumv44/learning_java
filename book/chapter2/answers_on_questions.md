### 1. Почему в Java строго определены диапазоны допустимых значений и области действия простых типов?

#### **Ответ:**
Для обеспечения переносимости программ, то есть кроссплатформенности. Только так можно было быть уверенными, что на разных платформах результат выполнения программ будет одинаковым.

### 2. Что собой представляет символьный тип в Java и чем он отличается от символьного типа в ряде других языков программирования?

#### **Ответ:**
Символьный тип данных в Java это не что иное как таблица Unicode символов. Это нужно было для того, чтобы дать возможность представлять символы всех языков мира, тем самым сделать язык гибким и популярных во всех странах.

### 3. "Переменная типа boolean может иметь любое значение, поскольку любое ненулевое значение интерпретируется как истинное". Верно или неверно?

#### **Ответ:**
Нет не верно! Тип boolean может содержать только два значения true или false (истина или ложь). Для каждых видов данных в Java имеется свой тип данных.

### 4. Допустим, результат выполнения программы выглядит следующим образом:
> Один <br/>
> Два <br/>
> Три

### Напишите строку кода вызова метода println(), где этот результат выводится в виде одной строки.

#### **Ответ:**
    System.out.println("Один\nДва\nТри");

### 5. Какая ошибка допущены в следующем фрагменте кода?

    for (i = 0; i < 10; i++) {
        int sum;
        sum = sum + 1;
    }
    System.out.println("Сумма: " + sum);

#### **Ответ:**
В данном примере не соблюдена область видимости (действия) переменной, при попытке откомпилировать будет выдана ошибка:

    Test.java:16: error: cannot find symbol
                    System.out.println("Сумма: " + sum);
                                                   ^
      symbol:   variable sum
      location: class Test
    1 error

Так как переменная sum ограничена областью действия цикла for и за его пределами она не существует. Далее, даже если исправить этот момент, то нельзя использовать переменную предварительно ее не инициализировав со значением согласно типа самой переменной, в результате чего программа выдаст ошибку при компиляции:

    Test.java:11: error: variable sum might not have been initialized
                            sum = sum + i;
                                  ^
    1 error

Если исправить и эту ошибку, то в результате выполнения программы мы получим числа от 0 до 9, вместо суммирования уже имеющихся числе как предполагается. Но это больше логическая ошибка, чем синтаксическая. Связано это с тем, что переменная sum будет жить только до окончания итерации цикла, и уже со следующей итерацией она будет снова инициализирована с начальным значением!

### 6. Поясните различие между префиксной и постфиксной формами записи операции инкремента.

#### **Ответ:**
Согласно установленного правила префиксная форма инкремента или декремента выполняет действие над переменной до ее использования в выражении, а постфиксаная после. **Например:**

    int x, y;
    x = 10;
    y = ++x;

в результате чего x и y будут иметь значение 11, в случае с постфиксной формой все будет немного иначе:

    int x, y;
    x = 10;
    y = x++;

здесь y будет равна 10, а x будет равна 11.

### 7. Покажите, каким образом укороченная логическая операция И может предотвратить деление на нуль.

### **Ответ:**
    class SCops {
    	public static void main(String[] args) {
    		int n, d, q;
    		d = 0; // установить для d нулевое значение
    		// Второй операнд не вычесляется, поскольку значение переменной d равно  нулю
    		if (d != 0 && (n % d) == 0) {
    			System.out.println(d + " является делителем " + n);
    		}
    		/* А теперь те же самые делителемствия выполняются без использования укороченного 
    		   логического  оператора. В результате возникает ошибка деления на нуль:
    		   Exception in thread "main" java.lang.ArithmeticException: / by zero
               at SCops.main(SCops.java:*)
    		*/
    		if (d != 0 & (n % d) == 0) {
    			System.out.println(d + " является делителем " + n);
    		}	
    	}
    }

В результате работы укороченной формы логической операции И в отличии от ее полной записи, выполняется проверка только первого условия и если оно ложно, то дальнейшее вычисление уже не выполняется.

### 10. До какого типа повышаются типа bute и short при вычислении выражений?

#### **Ответ:**
До типа int.

### 9. Когда возникает потребность в явном приведении типов?

#### **Ответ:**
Потребность в явном приведении типов возникает в случаи, когда результат выполнения выражения нужно привести к конкретно типу данных. Например, вместо double нужно получить значение типа int:

    double x, y;
    int d;
    d = (int) (x + y);

в этом случае результатом вычисления будет цело число (его дробная часть потеряется) типа int. Так же и с другими совместимы типами. Такое встречается на часто и поэтому нужно самому внимательно следить за типами данных и их диапазонами, дабы не получить неожиданный результат!

### 10. Оказывают ли избыточные скобки влияние на эффективность выполнения программ?

#### **Ответ:**
Нет, избыточные скобки напротив делают код более читабельным и логичным, но злоупотреблять ими не стоит.

### 11. Определяет ли блок кода область действия переменных?

#### **Ответ:**
Да. Переменная объявленная внутри какого-то блока кода, будет недоступно за его пределами, исключение являются только глобальные переменные или переменные класса. То есть если к примеру, переменная была объявлена внутри цикла, то за пределами цикла она уже не существует, а потому будет недоступна! А переменные объявленные до того же цикла, напротив будут доступны внутри цикла.
