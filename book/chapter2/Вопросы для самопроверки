1. Почему в Java строго определены диапазоны допустимых значений и области действия простых типов?

Ответ: Для обеспечения переносимости программ, то есть кроссплатформенности. Только так можно было быть уверенными, что на разных платформах результат выполнения программ будет одинаковым.

2. Что собой представляет символьный тип в Java и чем он отличается от символьного типа в ряде других языков программирования?

Ответ: Символьный тип данных в Java это не что иное как таблица Unicode символов. Это нужно было для того, чтобы дать возможность представлять символы всех языков мира, тем самым сделать язык гибким и популярных во всех странах.

3. "Переменная типа boolean может иметь любое значение, поскольку любое ненулевое значение интерпретируется как истинное". Верно или неверно?

Ответ: Нет не верно! Тип boolean может содержать только два значения true или false (истина или ложь). Для каждых видов данных в Java имеется свой тип данных.

4. Допустим, результат выполнения программы выглядит следующим образом:

Один
Два
Три

Напишите строку кода вызова метода println(), где этот результат выводится в виде одной строки.

Ответ: System.out.println("Один\nДва\nТри");

5. Какая ошибка допущены в следующем фрагменте кода?

for (i = 0; i < 10; i++) {
	int sum;
	sum = sum + 1;
}
System.out.println("Сумма: " + sum);

Ответ: В данном примере не соблюдена область видимости (действия) переменной, при попытке откомпилировать будет выдана ошибка:

Test.java:16: error: cannot find symbol
                System.out.println("Сумма: " + sum);
                                               ^
  symbol:   variable sum
  location: class Test
1 error

Так как переменная sum ограничена областью действия цикла for и за его пределами она не существует. Далее, даже если исправить этот момент, то нельзя использовать переменную предварительно ее не инициализировав со значением согласно типа самой переменной, в результате чего программа выдаст ошибку при компиляции:

Test.java:11: error: variable sum might not have been initialized
                        sum = sum + i;
                              ^
1 error

Если исправить и эту ошибку, то в результате выполнения программы мы получим числа от 0 до 9, вместо суммирования уже имеющихся числе как предполагается. Но это больше логическая ошибка, чем синтаксическая. Связано это с тем, что переменная sum будет жить только до окончания итерации цикла, и уже со следующей итерацией она будет снова инициализирована с начальным значением!

6. Поясните различие между префиксной и постфиксной формами записи операции инкремента.

Ответ: Согласно установленного правила префиксная форма инкремента или декремента выполняет действие над переменной до ее использования в выражении, а постфиксаная после. Например:

int x, y;
x = 10;
y = ++x;

в результате чего x и y будут иметь значение 11, в случае с постфиксной формой все будет немного иначе:

int x, y;
x = 10;
y = x++;

здесь y будет равна 10, а x будет равна 11.

7. Покажите, каким образом укороченная логическая операция И может предотвратить деление на нуль.

Ответ:

class SCops {
	public static void main(String[] args) {
		int n, d, q;

		d = 0; // установить для d нулевое значение

		// Второй операнд не вычесляется, поскольку значение переменной d равно  нулю
		if (d != 0 && (n % d) == 0) {
			System.out.println(d + " является делителем " + n);
		}

		/* А теперь те же самые делителемствия выполняются без использования укороченного 
		   логического  оператора. В результате возникает ошибка деления на нуль:
		   Exception in thread "main" java.lang.ArithmeticException: / by zero
           at SCops.main(SCops.java:*)
		*/
		if (d != 0 & (n % d) == 0) {
			System.out.println(d + " является делителем " + n);
		}	
	}
}

В результате работы укороченной формы логической операции И в отличии от ее полной записи, выполняется проверка только первого условия и если оно ложно, то дальнейшее вычисление уже не выполняется.

8. До какого типа повышаются типа bute и short при вычислении выражений?

Ответ: До типа int.

9. Когда возникает потребность в явном приведении типов?

Ответ: Потребность в явном приведении типов возникает в случаи, когда результат выполнения выражения нужно привести к конкретно типу данных. Например, вместо double нужно получить значение типа int:

double x, y;
int d;
d = (int) (x + y);

в этом случае результатом вычисления будет цело число (его дробная часть потеряется) типа int. Так же и с другими совместимы типами. Такое встречается на часто и поэтому нужно самому внимательно следить за типами данных и их диапазонами, дабы не получить неожиданный результат!

10. Оказывают ли избыточные скобки влияние на эффективность выполнения программ?

Ответ: Нет, избыточные скобки напротив делают код более читабельным и логичным, но злоупотреблять ими не стоит.

11. Определяет ли блок кода область действия переменных?

Ответ: Да. Переменная объявленная внутри какого-то блока кода, будет недоступно за его пределами, исключение являются только глобальные переменные или переменные класса. То есть если к примеру, переменная была объявлена внутри цикла, то за пределами цикла она уже не существует, а потому будет недоступна! А переменные объявленные до того же цикла, напротив будут доступны внутри цикла.
